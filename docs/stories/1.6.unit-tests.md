# Story 1.6: Add Unit Tests for Tactics Data Loading and Validation

## Status
Draft

## Story
**As a** developer,
**I want** automated tests for tactics data loading,
**so that** I can catch data schema errors and regressions early.

## Acceptance Criteria

1. Jest or Vitest configured for unit testing with TypeScript support
2. Tests written for tactics data loader utility covering: successful JSON parsing, valid schema validation, error handling for malformed JSON
3. Tests verify that all required fields (id, title, category, positions, descriptions) are present in loaded tactics
4. Tests verify that position coordinates are valid numbers within expected ranges
5. Test coverage for data loading utilities reaches at least 80%
6. Tests run successfully in CI pipeline (GitHub Actions)
7. `package.json` includes `test` script to run test suite

## Tasks / Subtasks

- [ ] Task 1: Configure Jest with Next.js integration (AC: 1)
  - [ ] Install Jest and dependencies: `npm install -D jest jest-environment-jsdom @testing-library/react @testing-library/jest-dom`
  - [ ] Install next/jest preset: Verify it's included with Next.js
  - [ ] Create `jest.config.js` using `next/jest`
  - [ ] Create `jest.setup.js` for test environment setup
  - [ ] Verify TypeScript support works
  - [ ] Add `test` script to package.json: `"test": "jest"`
  - [ ] Add `test:watch` script: `"test:watch": "jest --watch"`
  - [ ] Add `test:coverage` script: `"test:coverage": "jest --coverage"`

- [ ] Task 2: Set up Canvas API and IntersectionObserver mocks (AC: 1)
  - [ ] Add Canvas API mock to `jest.setup.js`
  - [ ] Add IntersectionObserver mock (required for Framer Motion)
  - [ ] Verify mocks don't interfere with tests
  - [ ] Import `@testing-library/jest-dom` for custom matchers

- [ ] Task 3: Create test fixtures for tactics data
  - [ ] Create `__tests__/fixtures/` directory
  - [ ] Create `high-press-fixture.json` with valid tactic data
  - [ ] Create `invalid-tactic-fixture.json` with missing required fields
  - [ ] Create `malformed-tactic-fixture.json` with JSON syntax errors
  - [ ] Create `mock-player-positions.json` with sample positions

- [ ] Task 4: Create mocks for tactics data loading
  - [ ] Create `__mocks__/tactics.ts`
  - [ ] Mock `fetch()` for tactics loading
  - [ ] Create mock implementations for success and failure scenarios
  - [ ] Export mock tactics array for use in component tests

- [ ] Task 5: Write tests for loadTactics() function (AC: 2, 3)
  - [ ] Create `__tests__/lib/tactics-loader.test.ts`
  - [ ] Test successful loading of all tactics
  - [ ] Test parsing of JSON into Tactic objects
  - [ ] Test required fields are present (id, title, category)
  - [ ] Test handling of fetch failure (network error)
  - [ ] Test handling of invalid JSON response
  - [ ] Test empty tactics array returned on error

- [ ] Task 6: Write tests for loadTacticById() function (AC: 2, 3)
  - [ ] Test successful loading of single tactic
  - [ ] Test 404 error when tactic not found
  - [ ] Test parsing and validation of tactic data
  - [ ] Test error thrown when required fields missing
  - [ ] Test malformed JSON handling

- [ ] Task 7: Write tests for position coordinate validation (AC: 4)
  - [ ] Test position coordinates are numbers
  - [ ] Test x coordinates in valid range (0-100)
  - [ ] Test y coordinates in valid range (0-100)
  - [ ] Test invalid coordinates (negative, >100, NaN)
  - [ ] Test positions array is not empty

- [ ] Task 8: Write tests for field rendering utilities
  - [ ] Create `__tests__/lib/field-rendering/canvas-renderer.test.ts`
  - [ ] Test `drawField()` function calls correct Canvas API methods
  - [ ] Test `drawPlayer()` function renders player at correct position
  - [ ] Test `normalizedToCanvas()` coordinate conversion
  - [ ] Verify Canvas context methods called with correct arguments

- [ ] Task 9: Write tests for TacticCard component
  - [ ] Create `__tests__/components/TacticCard.test.tsx`
  - [ ] Test component renders with props
  - [ ] Test tactic title displays correctly
  - [ ] Test category displays correctly
  - [ ] Test link href points to correct route
  - [ ] Test accessibility (ARIA labels)

- [ ] Task 10: Run tests and verify coverage (AC: 5)
  - [ ] Run `npm test` and verify all tests pass
  - [ ] Run `npm run test:coverage` and review report
  - [ ] Verify data loading utilities have ≥80% coverage
  - [ ] Identify untested code paths
  - [ ] Add tests for uncovered code if needed

- [ ] Task 11: Add test step to CI/CD pipeline (AC: 6)
  - [ ] Update `.github/workflows/ci.yml`
  - [ ] Add test step after lint step
  - [ ] Run `npm test` in CI
  - [ ] Configure CI to fail if tests fail
  - [ ] Verify CI runs tests on pull requests

- [ ] Task 12: Create README documentation for testing
  - [ ] Document how to run tests locally
  - [ ] Document test file structure and conventions
  - [ ] Document how to add new tests
  - [ ] Document coverage requirements (80% for utilities)
  - [ ] Document mocking strategy

## Dev Notes

### Previous Story Context
**From Story 1.1:**
- Jest setup files created: `jest.config.js`, `jest.setup.js`
- Canvas API and IntersectionObserver mocks already in `jest.setup.js`

**From Story 1.4:**
- `loadTactics()` and `loadTacticById()` functions in `lib/tactics-loader.ts`
- Tactic TypeScript interfaces defined in `lib/types.ts`
- Three tactics available for testing

**From Story 1.5:**
- Canvas rendering functions in `lib/field-rendering/canvas-renderer.ts`
- Coordinate conversion functions in `lib/field-rendering/field-types.ts`
- FieldCanvas component uses Canvas API (requires mocking)

### Jest Configuration with Next.js
**[Source: ui-architecture/frontend-tech-stack.md#jest-with-nextjest]**

**Why Jest (not Vitest):**
- Next.js first-class support via `next/jest`
- Automatic mocking of Next.js components (Image, Link)
- Path alias resolution built-in (`@/` imports work automatically)
- Larger Next.js + Jest community

**Jest Configuration (jest.config.js):**
```javascript
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  collectCoverageFrom: [
    'lib/**/*.{js,ts,tsx}',
    'components/**/*.{js,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
  ],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
}

module.exports = createJestConfig(customJestConfig)
```

### Test Environment Setup
**[Source: ui-architecture/frontend-tech-stack.md#typescript-configuration]**

**Jest Setup (jest.setup.js):**
```javascript
import '@testing-library/jest-dom'

// Mock Canvas API for FieldCanvas tests
HTMLCanvasElement.prototype.getContext = jest.fn(() => ({
  fillRect: jest.fn(),
  clearRect: jest.fn(),
  fillStyle: '',
  strokeStyle: '',
  lineWidth: 1,
  beginPath: jest.fn(),
  moveTo: jest.fn(),
  lineTo: jest.fn(),
  arc: jest.fn(),
  stroke: jest.fn(),
  fill: jest.fn(),
  strokeRect: jest.fn(),
}))

// Mock IntersectionObserver (used by Framer Motion)
global.IntersectionObserver = class IntersectionObserver {
  constructor() {}
  observe() {}
  unobserve() {}
  disconnect() {}
}

// Mock window.matchMedia (used by responsive components)
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(),
    removeListener: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
})
```

### Testing Strategy
**[Source: ui-architecture/testing-requirements.md]**

**Test Types:**
1. **Unit Tests:** Test individual functions in isolation
   - Tactics loader utilities
   - Field rendering functions
   - Coordinate conversion
   - Data validation

2. **Component Tests:** Test React components
   - TacticCard rendering
   - Props handling
   - Event handlers
   - Accessibility

3. **Integration Tests (Future):** Test component interactions
   - Tactic selection → Navigation → Detail view
   - Will be added in Epic 2, Story 2.7

**Test Structure: Arrange-Act-Assert**
```tsx
it('loads tactic by ID', async () => {
  // Arrange
  const tacticId = 'high-press'

  // Act
  const tactic = await loadTacticById(tacticId)

  // Assert
  expect(tactic.id).toBe(tacticId)
  expect(tactic.title).toBe('High Press')
})
```

### Example Test Files

**Tactics Loader Tests (__tests__/lib/tactics-loader.test.ts):**
```typescript
import { loadTactics, loadTacticById } from '@/lib/tactics-loader'

// Mock fetch globally
global.fetch = jest.fn()

describe('loadTactics', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('loads all tactics from index', async () => {
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => [
        { id: 'high-press', path: '/data/tactics/pressing/high-press.json' },
      ],
    })

    const tactics = await loadTactics()
    expect(tactics).toHaveLength(1)
  })

  it('returns empty array on fetch failure', async () => {
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
    })

    const tactics = await loadTactics()
    expect(tactics).toEqual([])
  })
})

describe('loadTacticById', () => {
  it('loads single tactic', async () => {
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        id: 'high-press',
        title: 'High Press',
        category: 'pressing',
      }),
    })

    const tactic = await loadTacticById('high-press')
    expect(tactic.id).toBe('high-press')
  })

  it('throws error when tactic not found', async () => {
    (global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: false,
    })

    await expect(loadTacticById('invalid')).rejects.toThrow('Tactic not found')
  })
})
```

**Canvas Renderer Tests (__tests__/lib/field-rendering/canvas-renderer.test.ts):**
```typescript
import { drawField, drawPlayer } from '@/lib/field-rendering/canvas-renderer'

describe('drawField', () => {
  let ctx: CanvasRenderingContext2D

  beforeEach(() => {
    const canvas = document.createElement('canvas')
    ctx = canvas.getContext('2d') as CanvasRenderingContext2D
  })

  it('draws field background', () => {
    drawField(ctx, 400, 600)
    expect(ctx.fillRect).toHaveBeenCalledWith(0, 0, 400, 600)
  })

  it('draws center line', () => {
    drawField(ctx, 400, 600)
    expect(ctx.moveTo).toHaveBeenCalled()
    expect(ctx.lineTo).toHaveBeenCalled()
  })

  it('draws center circle', () => {
    drawField(ctx, 400, 600)
    expect(ctx.arc).toHaveBeenCalled()
  })
})

describe('drawPlayer', () => {
  let ctx: CanvasRenderingContext2D

  beforeEach(() => {
    const canvas = document.createElement('canvas')
    ctx = canvas.getContext('2d') as CanvasRenderingContext2D
  })

  it('draws player at correct position', () => {
    drawPlayer(ctx, 100, 200)
    expect(ctx.arc).toHaveBeenCalledWith(100, 200, expect.any(Number), 0, 2 * Math.PI)
  })
})
```

**TacticCard Component Tests (__tests__/components/TacticCard.test.tsx):**
```tsx
import { render, screen } from '@testing-library/react'
import { TacticCard } from '@/components/TacticCard'

describe('TacticCard', () => {
  const mockProps = {
    id: 'high-press',
    title: 'High Press',
    category: 'pressing' as const,
  }

  it('renders tactic title', () => {
    render(<TacticCard {...mockProps} />)
    expect(screen.getByText('High Press')).toBeInTheDocument()
  })

  it('renders category', () => {
    render(<TacticCard {...mockProps} />)
    expect(screen.getByText('pressing')).toBeInTheDocument()
  })

  it('links to tactic detail page', () => {
    render(<TacticCard {...mockProps} />)
    const link = screen.getByRole('link')
    expect(link).toHaveAttribute('href', '/tactic/high-press')
  })
})
```

### Position Validation Tests
**Coordinate Range Validation:**
```typescript
import { validatePosition } from '@/lib/field-rendering/field-types'

describe('validatePosition', () => {
  it('accepts valid coordinates', () => {
    const position = { x: 50, y: 75 }
    expect(validatePosition(position)).toBe(true)
  })

  it('rejects x coordinate < 0', () => {
    const position = { x: -10, y: 50 }
    expect(validatePosition(position)).toBe(false)
  })

  it('rejects x coordinate > 100', () => {
    const position = { x: 150, y: 50 }
    expect(validatePosition(position)).toBe(false)
  })

  it('rejects y coordinate < 0', () => {
    const position = { x: 50, y: -10 }
    expect(validatePosition(position)).toBe(false)
  })

  it('rejects y coordinate > 100', () => {
    const position = { x: 50, y: 150 }
    expect(validatePosition(position)).toBe(false)
  })

  it('rejects non-numeric coordinates', () => {
    const position = { x: NaN, y: 50 }
    expect(validatePosition(position)).toBe(false)
  })
})
```

### Test Coverage Requirements
**[Source: ui-architecture/testing-requirements.md]**

**Coverage Goals:**
- **Utilities (lib/):** 90% coverage
- **Components:** 70% coverage
- **Overall:** 80% coverage

**Coverage Threshold Enforcement:**
```javascript
// jest.config.js
coverageThreshold: {
  global: {
    branches: 70,
    functions: 80,
    lines: 80,
    statements: 80,
  },
  './lib/**/*.ts': {
    branches: 90,
    functions: 90,
    lines: 90,
    statements: 90,
  },
}
```

**Run Coverage:**
```bash
npm run test:coverage
```

**View Coverage Report:**
```bash
open coverage/lcov-report/index.html
```

### CI/CD Integration
**[Source: ui-architecture/project-structure.md#github-section]**

**Update .github/workflows/ci.yml:**
```yaml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20.x
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run tests              # NEW STEP
        run: npm test                # NEW STEP

      - name: Build project
        run: npm run build
```

**CI Behavior:**
- Tests run on every PR and push to main
- CI fails if any test fails
- Blocks merging PRs with failing tests

### Package.json Scripts
**[Source: ui-architecture/frontend-developer-standards.md#quick-reference]**

**Add to package.json:**
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

**Usage:**
```bash
npm test                  # Run all tests once
npm run test:watch        # Run tests in watch mode (re-runs on file changes)
npm run test:coverage     # Generate coverage report
```

### Mocking Strategy
**[Source: ui-architecture/testing-requirements.md]**

**Mock External Dependencies:**
1. **fetch():** Mock for tactics loading tests
2. **Canvas API:** Mock in jest.setup.js (already configured)
3. **localStorage:** Mock for theme/format persistence tests (future)
4. **IntersectionObserver:** Mock for Framer Motion (already configured)

**Mock Pattern:**
```typescript
// Mock fetch globally
global.fetch = jest.fn()

// Mock implementation per test
(global.fetch as jest.Mock).mockResolvedValueOnce({
  ok: true,
  json: async () => ({ /* data */ }),
})
```

### Test File Structure
**[Source: ui-architecture/project-structure.md#tests-directory]**

```
__tests__/
├── components/
│   ├── TacticCard.test.tsx
│   ├── FieldCanvas.test.tsx
│   └── AnimationControls.test.tsx
├── lib/
│   ├── tactics-loader.test.ts
│   └── field-rendering/
│       ├── canvas-renderer.test.ts
│       └── field-types.test.ts
├── fixtures/
│   ├── high-press-fixture.json
│   ├── invalid-tactic-fixture.json
│   └── mock-player-positions.json
└── integration/           # Future (Epic 2, Story 2.7)
```

### Common Testing Pitfalls to Avoid

**[Source: ui-architecture/frontend-developer-standards.md]**

1. ❌ Not mocking Canvas API (tests fail in JSDOM)
2. ❌ Not mocking fetch (tests fail with network errors)
3. ❌ Hardcoding test data instead of using fixtures
4. ❌ Not testing error paths (only happy path)
5. ❌ Not clearing mocks between tests (`jest.clearAllMocks()`)
6. ❌ Testing implementation details instead of behavior
7. ❌ Not using `@testing-library/jest-dom` matchers

### Documentation for Contributors

**Create TESTING.md or add to README.md:**
```markdown
## Running Tests

### Run all tests
```bash
npm test
```

### Run tests in watch mode
```bash
npm run test:watch
```

### Generate coverage report
```bash
npm run test:coverage
```

### Writing Tests

- Place test files in `__tests__/` directory
- Use `.test.ts` or `.test.tsx` suffix
- Follow Arrange-Act-Assert pattern
- Mock external dependencies (fetch, Canvas, etc.)
- Aim for 80% coverage on utilities

### Example Test
```typescript
import { loadTacticById } from '@/lib/tactics-loader'

describe('loadTacticById', () => {
  it('loads tactic successfully', async () => {
    // Arrange
    const tacticId = 'high-press'

    // Act
    const tactic = await loadTacticById(tacticId)

    // Assert
    expect(tactic.id).toBe(tacticId)
  })
})
```
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Initial story creation from Epic 1, Story 1.6 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes List
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results
_To be populated by QA agent after implementation_
