# Story 1.5: Implement Canvas-Based Field Rendering with Player Positions and Animation Prototype

## Status
Draft

## Story
**As a** volunteer coach,
**I want** to see a visual soccer field with player positions when I select a tactic,
**so that** I can understand the positional setup before showing it to my team.

## Acceptance Criteria

1. Tactic detail view created with full-screen Canvas element for field rendering
2. Canvas renders a soccer field with proper proportions (green background, white lines, center circle, penalty areas)
3. Player positions from JSON data rendered as circles or icons on the field at correct coordinates
4. Field auto-scales to fit mobile viewport while maintaining aspect ratio
5. Field rendering adapts to portrait and landscape orientations
6. Visual contrast is sufficient for outdoor readability (bright colors, thick lines)
7. Touch-friendly back button navigates from detail view to tactics grid
8. Selected tactic title and description displayed above or below field canvas
9. **Framer Motion library installed and integrated into project** (early technical risk validation)
10. **Prototype animation created showing at least 2 players moving between positions** to validate animation approach and performance
11. **Frame rate measured on target devices** (iPhone 8 / Samsung Galaxy A-series or equivalent emulator) confirming ≥30 FPS is achievable with current architecture

## Tasks / Subtasks

- [ ] Task 1: Install and configure Framer Motion (AC: 9)
  - [ ] Install Framer Motion: `npm install framer-motion`
  - [ ] Verify version 11.0+ installed
  - [ ] Create `lib/motion.tsx` with LazyMotion provider wrapper
  - [ ] Wrap app with MotionProvider in `app/layout.tsx`
  - [ ] Test basic animation to verify installation

- [ ] Task 2: Create FieldCanvas component (AC: 1, 2, 4, 5, 6)
  - [ ] Create `components/FieldCanvas.tsx`
  - [ ] Define `FieldCanvasProps` interface accepting `tactic: Tactic`
  - [ ] Add `'use client'` directive (uses Canvas API and refs)
  - [ ] Create canvas ref and set up rendering context
  - [ ] Implement responsive canvas sizing (maintain aspect ratio)
  - [ ] Handle window resize events
  - [ ] Support portrait and landscape orientations

- [ ] Task 3: Implement field rendering logic (AC: 2, 6)
  - [ ] Create `lib/field-rendering/canvas-renderer.ts`
  - [ ] Implement `drawField(ctx, width, height)` function
  - [ ] Draw green background
  - [ ] Draw white field lines (center line, touchlines, goal lines)
  - [ ] Draw center circle
  - [ ] Draw penalty areas (simplified for 5v5)
  - [ ] Use thick lines (3-5px) for outdoor readability
  - [ ] Use high-contrast colors (white on green)

- [ ] Task 4: Implement player position rendering (AC: 3)
  - [ ] Create `lib/field-rendering/field-types.ts` for field-specific types
  - [ ] Implement coordinate conversion: normalized (0-100) → canvas pixels
  - [ ] Implement `drawPlayer(ctx, position, color)` function
  - [ ] Render players as circles or simple icons
  - [ ] Position players based on JSON coordinates
  - [ ] Use contrasting colors for visibility

- [ ] Task 5: Update tactic detail page with FieldCanvas (AC: 1, 7, 8)
  - [ ] Update `app/tactic/[id]/page.tsx`
  - [ ] Import FieldCanvas component
  - [ ] Pass tactic data to FieldCanvas
  - [ ] Display tactic title above canvas
  - [ ] Display tactic description below canvas
  - [ ] Add back button with Link to home page
  - [ ] Make back button touch-friendly (min 44px height)

- [ ] Task 6: Implement responsive canvas sizing (AC: 4, 5)
  - [ ] Calculate canvas dimensions based on viewport
  - [ ] Maintain field aspect ratio (typically 1.5:1 or 2:1)
  - [ ] Handle mobile portrait: canvas width = viewport width - padding
  - [ ] Handle mobile landscape: canvas height = viewport height - padding
  - [ ] Re-render on orientation change
  - [ ] Test on devices with different aspect ratios

- [ ] Task 7: Create animation engine foundation (AC: 9, 10)
  - [ ] Create `lib/field-rendering/animation-engine.ts`
  - [ ] Define animation keyframe structure
  - [ ] Implement basic animation loop using Framer Motion
  - [ ] Integrate with canvas rendering
  - [ ] Support start/stop animation controls

- [ ] Task 8: Create prototype animation (AC: 10)
  - [ ] Select 2 players from high-press tactic
  - [ ] Define start and end positions for both players
  - [ ] Implement animation using Framer Motion's `animate()` API
  - [ ] Animate player positions over 2-3 seconds
  - [ ] Clear and re-render canvas on each animation frame
  - [ ] Verify smooth movement

- [ ] Task 9: Create AnimationControls component (AC: 10)
  - [ ] Create `components/AnimationControls.tsx`
  - [ ] Add Play button
  - [ ] Add Pause button
  - [ ] Add Restart button
  - [ ] Connect to animation engine state
  - [ ] Make buttons touch-friendly (min 44px)

- [ ] Task 10: Integrate animation with FieldCanvas
  - [ ] Add animation state to FieldCanvas component
  - [ ] Render AnimationControls in tactic detail view
  - [ ] Connect controls to animation engine
  - [ ] Test play/pause/restart functionality
  - [ ] Verify canvas updates during animation

- [ ] Task 11: Measure and validate frame rate (AC: 11)
  - [ ] Add FPS counter (development only)
  - [ ] Test on iPhone 8 simulator or equivalent
  - [ ] Test on Samsung Galaxy A-series emulator or equivalent
  - [ ] Test on real mobile device if available
  - [ ] Verify ≥30 FPS during animation
  - [ ] Document frame rate results
  - [ ] If <30 FPS, identify performance bottlenecks

- [ ] Task 12: Add accessibility features for canvas
  - [ ] Add hidden semantic HTML describing field and positions
  - [ ] Use `aria-hidden="true"` on canvas element
  - [ ] Create screen-reader-friendly description of tactic
  - [ ] Ensure WCAG 2.1 AA compliance

- [ ] Task 13: Test outdoor readability
  - [ ] Test on mobile device in bright light
  - [ ] Verify field lines are visible
  - [ ] Verify player positions are distinguishable
  - [ ] Adjust colors/contrast if needed
  - [ ] Test with sunglasses on (simulates harsh outdoor glare)

## Dev Notes

### Previous Story Context
**From Story 1.4:**
- Tactic data structure defined with `Position[]` in JSON
- Coordinates normalized 0-100 for responsive rendering
- `loadTacticById()` function available to fetch tactic data
- Three tactics available: high-press, build-up-play, compact-defense

**From Story 1.3:**
- Tactic detail page route exists at `app/tactic/[id]/page.tsx`
- Back navigation pattern established

### Canvas Rendering Architecture
**[Source: ui-architecture/frontend-tech-stack.md#canvas-api]**

**Dual Rendering Approach (Accessibility):**
1. **Canvas:** Visual rendering for sighted users (high performance)
2. **Hidden HTML:** Semantic description for screen readers (WCAG 2.1 AA)

**Why Canvas over SVG:**
- **Performance:** Canvas GPU rendering achieves 60 FPS vs SVG's 18-22 FPS
- **Target:** 30 FPS minimum on iPhone 8 with 9 players animating
- **Trade-off:** Canvas is bitmap (not scalable), but performance gain justifies it

**Accessibility Pattern:**
```tsx
<div className="field-container">
  {/* Visual rendering */}
  <canvas ref={canvasRef} aria-hidden="true" />

  {/* Hidden accessible version */}
  <div className="sr-only" role="region" aria-label="Tactical animation">
    <p>{tactic.description.professional}</p>
    <ul>
      {tactic.formats['5v5']?.positions.map((pos, i) => (
        <li key={i}>Player {i+1}: {pos.role || 'player'}</li>
      ))}
    </ul>
  </div>
</div>
```

### Framer Motion with LazyMotion
**[Source: ui-architecture/frontend-tech-stack.md#framer-motion-lazymotion]**

**Problem:** Full Framer Motion library is ~120KB (too large for 2MB budget)

**Solution:** LazyMotion splits features into lazy-loaded chunks

**Implementation (lib/motion.tsx):**
```tsx
'use client'
import { LazyMotion, domAnimation } from "framer-motion"

export default function MotionProvider({ children }: { children: React.ReactNode }) {
  return (
    <LazyMotion features={domAnimation}>
      {children}
    </LazyMotion>
  )
}
```

**Usage in components:**
```tsx
import { m } from "framer-motion"

// Use m.div instead of motion.div
<m.div animate={{ x: 100 }} />
```

**Bundle Impact:**
- Initial load: 45KB (LazyMotion core)
- First animation: +30KB (lazy-loaded features)
- **Total savings: ~50KB** vs full Framer Motion

### Field Rendering Specifications
**[Source: lib/field-rendering/canvas-renderer.ts - to be created]**

**Field Dimensions:**
- Aspect ratio: 1.5:1 (length:width) for 5v5
- Responsive: fit within viewport while maintaining aspect ratio

**Field Elements:**
- Background: Green (#2d5016 or similar grass color)
- Lines: White (#ffffff) with 4px stroke width
- Center circle: 20% of field width diameter
- Penalty areas: Simplified rectangles (10% of field length)

**Drawing Order:**
1. Clear canvas
2. Draw background (green rectangle)
3. Draw field lines (white)
4. Draw center circle
5. Draw penalty areas
6. Draw player positions

**Code Structure:**
```typescript
export function drawField(
  ctx: CanvasRenderingContext2D,
  width: number,
  height: number
) {
  // Clear canvas
  ctx.clearRect(0, 0, width, height)

  // Draw green background
  ctx.fillStyle = '#2d5016'
  ctx.fillRect(0, 0, width, height)

  // Draw white lines
  ctx.strokeStyle = '#ffffff'
  ctx.lineWidth = 4

  // Center line
  ctx.beginPath()
  ctx.moveTo(0, height / 2)
  ctx.lineTo(width, height / 2)
  ctx.stroke()

  // Touchlines and goal lines
  ctx.strokeRect(0, 0, width, height)

  // Center circle
  const centerX = width / 2
  const centerY = height / 2
  const radius = width * 0.1
  ctx.beginPath()
  ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI)
  ctx.stroke()

  // Penalty areas (simplified)
  const penaltyWidth = width * 0.4
  const penaltyHeight = height * 0.1
  ctx.strokeRect((width - penaltyWidth) / 2, 0, penaltyWidth, penaltyHeight)
  ctx.strokeRect((width - penaltyWidth) / 2, height - penaltyHeight, penaltyWidth, penaltyHeight)
}
```

### Coordinate Conversion
**[Source: lib/field-rendering/field-types.ts - to be created]**

**Convert normalized (0-100) to canvas pixels:**
```typescript
export function normalizedToCanvas(
  position: Position,
  canvasWidth: number,
  canvasHeight: number
): { x: number, y: number } {
  return {
    x: (position.x / 100) * canvasWidth,
    y: (position.y / 100) * canvasHeight
  }
}
```

**Player Rendering:**
```typescript
export function drawPlayer(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  radius: number = 10,
  color: string = '#ff0000'
) {
  ctx.fillStyle = color
  ctx.beginPath()
  ctx.arc(x, y, radius, 0, 2 * Math.PI)
  ctx.fill()

  // Optional: Add outline for visibility
  ctx.strokeStyle = '#ffffff'
  ctx.lineWidth = 2
  ctx.stroke()
}
```

### Animation Prototype Strategy
**[Source: ui-architecture/frontend-tech-stack.md#framer-motion]**

**Objective:** Validate animation architecture early to derisk Epic 2

**Prototype Animation:**
- 2 players from high-press tactic
- Move from initial positions to new positions over 2 seconds
- Use Framer Motion's `animate()` function
- Re-render canvas on each frame

**Implementation Pattern:**
```tsx
import { animate } from 'framer-motion'

function animatePlayer(
  startPos: Position,
  endPos: Position,
  duration: number,
  onUpdate: (pos: Position) => void
) {
  animate(0, 100, {
    duration: duration,
    onUpdate: (progress) => {
      const x = startPos.x + (endPos.x - startPos.x) * (progress / 100)
      const y = startPos.y + (endPos.y - startPos.y) * (progress / 100)
      onUpdate({ x, y })
    }
  })
}
```

**Canvas Animation Loop:**
```tsx
const animate = () => {
  // Clear canvas
  ctx.clearRect(0, 0, width, height)

  // Draw field
  drawField(ctx, width, height)

  // Draw players at current animated positions
  animatedPositions.forEach(pos => {
    const canvasPos = normalizedToCanvas(pos, width, height)
    drawPlayer(ctx, canvasPos.x, canvasPos.y)
  })

  // Continue animation
  if (isPlaying) {
    requestAnimationFrame(animate)
  }
}
```

### Frame Rate Measurement
**[Source: ui-architecture/frontend-tech-stack.md#performance]**

**Target:** ≥30 FPS on iPhone 8 / Samsung Galaxy A-series

**FPS Counter (development only):**
```typescript
let lastTime = Date.now()
let frames = 0

function measureFPS() {
  frames++
  const currentTime = Date.now()
  if (currentTime >= lastTime + 1000) {
    const fps = frames
    console.log('FPS:', fps)
    frames = 0
    lastTime = currentTime
  }
}

// Call in animation loop
requestAnimationFrame(() => {
  measureFPS()
  animate()
})
```

**Test Devices:**
- iPhone 8 (2017, A11 Bionic) - baseline iOS device
- Samsung Galaxy A-series (mid-range Android) - baseline Android device
- Use iOS Simulator / Android Emulator if real devices unavailable

**Success Criteria:**
- ✅ FPS ≥ 30 during animation
- ❌ FPS < 30 → investigate performance bottlenecks (fewer players, simpler rendering, etc.)

### Responsive Canvas Sizing
**[Source: components/FieldCanvas.tsx - to be created]**

**Challenge:** Canvas must fit viewport while maintaining aspect ratio

**Solution:**
```tsx
function calculateCanvasDimensions(
  viewportWidth: number,
  viewportHeight: number
): { width: number, height: number } {
  const aspectRatio = 1.5 // Field aspect ratio (length:width)
  const padding = 32 // px

  const maxWidth = viewportWidth - padding
  const maxHeight = viewportHeight - padding * 2

  // Calculate dimensions maintaining aspect ratio
  let width = maxWidth
  let height = width / aspectRatio

  if (height > maxHeight) {
    height = maxHeight
    width = height * aspectRatio
  }

  return { width, height }
}
```

**Handling Orientation Changes:**
```tsx
useEffect(() => {
  function handleResize() {
    const dims = calculateCanvasDimensions(window.innerWidth, window.innerHeight)
    setCanvasWidth(dims.width)
    setCanvasHeight(dims.height)
  }

  window.addEventListener('resize', handleResize)
  window.addEventListener('orientationchange', handleResize)

  return () => {
    window.removeEventListener('resize', handleResize)
    window.removeEventListener('orientationchange', handleResize)
  }
}, [])
```

### Outdoor Readability
**[Source: ui-architecture/styling-guidelines.md]**

**Problem:** Coaches use app on sidelines in bright sunlight

**Solutions:**
1. **High Contrast:** White lines on dark green (7:1 contrast ratio)
2. **Thick Lines:** 4-5px strokes (visible from arms length)
3. **Bright Player Colors:** Red, blue, yellow (avoid pastels)
4. **Outlined Players:** White outlines around player circles

**Test Conditions:**
- Bright sunlight (outdoors)
- Simulated with iPhone max brightness in direct light
- Test with polarized sunglasses (some coaches wear them)

### Component Structure

**New Files:**
- `components/FieldCanvas.tsx` - Canvas rendering component
- `components/AnimationControls.tsx` - Play/pause/restart buttons
- `lib/motion.tsx` - LazyMotion provider
- `lib/field-rendering/canvas-renderer.ts` - Field drawing utilities
- `lib/field-rendering/animation-engine.ts` - Animation logic
- `lib/field-rendering/field-types.ts` - Field-specific types

**Modified Files:**
- `app/layout.tsx` - Wrap with MotionProvider
- `app/tactic/[id]/page.tsx` - Add FieldCanvas and AnimationControls
- `package.json` - Add Framer Motion dependency

### Testing

**[Source: ui-architecture/testing-requirements.md]**

**Manual Testing:**
1. **Canvas Rendering:**
   - Visit tactic detail page
   - Verify field renders with green background and white lines
   - Verify player positions appear at correct locations
   - Test on different viewport sizes (375px, 768px, 1280px)

2. **Animation Prototype:**
   - Click Play button
   - Verify 2 players animate smoothly
   - Verify ≥30 FPS (use browser DevTools Performance tab)
   - Click Pause → verify animation stops
   - Click Restart → verify animation resets

3. **Responsiveness:**
   - Rotate device (portrait ↔ landscape)
   - Verify canvas resizes while maintaining aspect ratio
   - Test on different devices (iOS, Android)

4. **Accessibility:**
   - Enable VoiceOver (iOS) or TalkBack (Android)
   - Verify screen reader announces tactic description
   - Verify player positions are described

**Performance Testing:**
- Use Chrome DevTools → Performance → Record
- Measure FPS during animation
- Identify dropped frames or jank
- Optimize if FPS < 30

**Automated Testing (Story 1.6):**
- Mock Canvas API in tests (already set up in jest.setup.js)
- Test coordinate conversion functions
- Test field rendering logic (verify draw calls)

### Common Pitfalls to Avoid

**[Source: ui-architecture/frontend-developer-standards.md]**

1. ❌ Forgetting `'use client'` directive on FieldCanvas (uses refs, Canvas API)
2. ❌ Not clearing canvas before each frame (causes ghosting)
3. ❌ Using pixel coordinates instead of normalized (breaks responsiveness)
4. ❌ Not handling resize/orientation change events
5. ❌ Canvas too small (text/lines unreadable)
6. ❌ Canvas too large (performance issues, memory)
7. ❌ Forgetting accessibility (aria-hidden on canvas, semantic HTML alternative)
8. ❌ Not testing on real mobile devices (emulators don't reflect true performance)

### Performance Optimization Tips

**If FPS < 30:**
1. **Reduce Canvas Size:** Smaller canvas = fewer pixels to render
2. **Simplify Field:** Remove unnecessary details (e.g., corner arcs)
3. **Fewer Players:** Test with 3 players instead of 5
4. **Hardware Acceleration:** Ensure canvas uses GPU (usually automatic)
5. **Throttle Animation:** 30 FPS target instead of 60 FPS

**Canvas Performance Best Practices:**
- Avoid unnecessary `clearRect()` calls
- Batch draw operations
- Use `requestAnimationFrame()` for smooth animations
- Avoid DOM manipulation during animation loop

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Initial story creation from Epic 1, Story 1.5 | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes List
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results
_To be populated by QA agent after implementation_
